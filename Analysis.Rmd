---
title: "Randomization Analysis"
author: "Orion Bowers"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(forecast)
```

```{bash data_cleaning, eval = FALSE, echo = FALSE, skip=TRUE}
cat CalSoup.txt | tr " " $'\n' > CalSoupCleaned.txt
cat Rrunif.txt | tr '"x"' " " > RrunifCleaned.txt
cat Rsample.txt | tr '"x"' " " > RsampleCleaned.txt
```

```{r data_importing, include=FALSE}
#Online (CalSoup, NumGenerator, Randorg, Textfixer)
soup <- read_csv("Data/CalSoupCleaned.txt", col_names = FALSE) %>% pull("X1")
ngen <- read_csv("Data/NumGenerator.txt", col_names=FALSE) %>% pull("X1")
randorg <- read_csv("Data/Randorg.txt", col_names=FALSE) %>% pull("X1")
tfix <- read_csv("Data/Textfixer.txt", col_names=FALSE) %>% pull("X1")

#R (Rrunif, Rsample) (Rdunif same as Rsample)
runi <- read_csv("Data/Rrunif.txt") %>% pull("x")
rsam <- read_csv("Data/Rsample.txt") %>% pull("x")

#Python (Prand, Pnprand) (Python's base number generator and numpy's number generator)
prand <- read_csv("Data/Prand.txt", col_names=FALSE) %>% pull("X1")
nprand <- read_csv("Data/Pnprand.txt", col_names=FALSE) %>% pull("X1")

#Physical Generation (d20)
d20 <- read_csv("Data/d20.txt", col_names=FALSE) %>% pull("X1")


propsTable <- tibble("Number" = as.factor(c(1:16)))

addData <- function(newData, newDataName, initialData) {
  propsTable <- full_join(initialData,count(read_csv(newData, col_names = "Number"), Number, name = newDataName))
}

#Physical Generation (20 d20s rolled repeatedly. Rolls from 17-20 were thrown out)
propsTable <- addData("Data/d20.txt","d20",propsTable)

#Online (CalSoup, NumGenerator, Randorg, Textfixer)
propsTable <- addData("Data/CalSoupCleaned.txt","soup",propsTable)
propsTable <- addData("Data/NumGenerator.txt","ngen",propsTable)
propsTable <- addData("Data/Randorg.txt","randorg",propsTable)
propsTable <- addData("Data/Textfixer.txt","tfix",propsTable)

#R (Rrunif, Rsample) (Rdunif same as Rsample)
propsTable <- addData("Data/RrunifCleaned.txt","runi",propsTable)
propsTable <- addData("Data/RsampleCleaned.txt","rsam",propsTable)

#Python (Prand, Pnprand) (Python's base number generator and numpy's number generator)
propsTable <- addData("Data/Prand.txt","prand",propsTable)
propsTable <- addData("Data/Pnprand.txt","nprand",propsTable)

propsTable


#TODO: test on runs of same number from rand.org

#TODO: Bayesian: Prior of a uniform, likelihood of the data


```

## Randomization Analysis by different programming languages
The purpose of this project is to determine which programming languages (or other sources) have the most truly random draws.
This project is inspired by Arkham Horror: The Card Game, which requires drawing 1 out of approximately 16 tokens from a bag with replacement many times throughout a game session. I'll be taking a look at R's random sample, R's continuous uniform function, Python's random sample, C++'s random sample, a Google Search, and Chat GPT's answer. I expect either Python or R to perform the best.

I'll be taking a random sample from a "bag" of numbers 1 - 16 inclusive and with replacement.

Later, I may check if R and Python and C++ can generate whole numbers from a distribution without using a random sample method.

To determine the randomness, I'll check the Poisson distribution of each number to see if the mean is the expected mean and variance is the expected variance for the count of that number. I'll also check the histograms of of each generator for a discrete uniform look and try to find a test that tests that.

The Discrete Uniform Distribution has the following properties (https://www.sciencedirect.com/topics/mathematics/discrete-uniform-distribution, https://www.math.net/uniform-distribution):
 - PMF: $p(y) = \frac{1}{k}, y = 1,2,...,k$
 - Mean: $\mu = \frac{k+1}{2}$
 - Variance: $\sigma^2 = \frac{(k-1)^2}{12}$
 
 
 ### R: Continuous Uniform Sample to Discrete Uniform
 "To generate a random number from the discrete uniform distribution, one can draw a random number R from the U(0, 1) distribution, calculate S = (n + 1)R, and take the integer part of S as the draw from the discrete uniform distribution." (https://www.sciencedirect.com/topics/mathematics/discrete-uniform-distribution)
 
 ### Discrete Uniform Distribution Information
https://en.wikipedia.org/wiki/Discrete_uniform_distribution
https://www.random.org/statistics/runs/
https://www.random.org/analysis/
(Randorg.txt) (Seed 121)

https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php
(CalSoup.txt) (No Seed)
https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php?min=1&max=16&num_samples=10000&duplicates=yes&sort_answer=none&action=solve
Cite this content, page or calculator as:
Furey, Edward "Random Number Generator" at https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php from CalculatorSoup, https://www.calculatorsoup.com - Online Calculators

https://numbergenerator.org/randomnumbergenerator#!numbers=10000&low=1&high=16&unique=false&csv=nl&oddeven=&oddqty=0&sorted=false&addfilters=
(NumGenerator.txt) (No Seed)

https://www.textfixer.com/numbers/random-number-generator.php
(Textfixer.txt) (No Seed)


Leads:
https://stackoverflow.com/questions/55327771/c-how-to-generate-10-000-unique-random-integers-to-store-in-a-bst



## Hypothesis Testing

```{r bar_charts}
columns_to_plot <- names(propsTable)[names(propsTable) != "Number"]

# Loop through each column
for (col in columns_to_plot) {
  col_mean <- mean(propsTable[[col]])
  
  p <- ggplot(data = propsTable, aes(x=Number, y = !!sym(col))) +
    geom_bar(stat="Identity") +
    geom_hline(yintercept = col_mean, color = "red", linetype = "dashed") +  # Add mean line
    labs(title = col)  # Add title for each plot
  
  # Print the plot
  print(p)
}
```

As n increases, the visual variance reduces drastically. TODO: Because I generated more from better methods or because n is large?



```{r chi_test}
## Chi Squared Goodness of Fit Tests
# H0: Follows a uniform
# Ha: Doesn't follow a uniform
# Expected Frequency: n / 16
# Observed Frequency: data in propsTable
# X^2 = Sum( (Oi - Ei)**2 / Ei)

## This spits out the same probability as chisq.test below but it's more work
# n <- sum(propsTable$soup)
# Ei <- n / 16
# j <- tibble("soup" = rep(0, times=16))
# 
# for (i in 1:16) {
#   j$soup[i] <- (((propsTable$soup[i] - Ei)**2)/Ei)
# }
# p_value <- 1 - pchisq(sum(j), 15)



for (col in names(propsTable[, -1])) {
  # X^2 test for the current column
  test_result <- chisq.test(propsTable[col])
  
  cat("Chi-squared goodness-of-fit test for column:", col)
  print(test_result)
  cat("-------------------------------------------------------\n")
}
```

```{r mean_var_test}
# Expected Mean: (a+b/2) = (1+16/2) = 8.5
# Observed Mean: mean(data)
# H0: Means are the same
# Ha: Means are statistically different

# Loop through each column
for (dat in columns_to_plot) {
  t <- t.test(get(dat), mu=8.5)
  
  cat("One sided t-test for mean for column:", dat)
  print(t)
  cat("-------------------------------------------------------\n")
}

# Expected Variance: (((b-a+1)**2) - 1) / 12 = ((16**2) - 1) / 12 = 21.25
# Observed Variance: var(data)
# H0: Variance is the same
# Ha: Variance is statistically different
# Manually doing the test since F test isn't appropriate w/ theoretical variance
# And t.test() checks mean and can't check variance

for (dat in columns_to_plot) {
  d_f <- length(get(dat)) - 1 # deg of freedom
  t_stat <- (var(get(dat)) - 21.25) / sqrt((d_f * (21.25**2)) / (2 * d_f))
  t <- pt(t_stat, df=d_f)
  cat("One sided t-test for variance for column:", dat,'\n')
  cat("t-statistic =",t_stat,"p-value:",t,'\n')
  cat("-------------------------------------------------------\n")
}
```


## Assumptions

```{r assumptions}
# Independence
columns_to_plot <- names(propsTable)[names(propsTable) != "Number"]

# Loop through each column
for (dat in columns_to_plot) {
  p <- ggAcf(get(dat), lag.max = 100) + labs(title = dat)
  print(p)
}
```

While there are a few lines that poke out for each chart, independence seems met.

## Ethical considerations